#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in2,    liftEnc,        sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in8,    powerExpander,  sensorAnalog)
#pragma config(Sensor, dgtl1,  claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl2,  cubeAuton,      sensorTouch)
#pragma config(Sensor, dgtl8,  leftDriveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl10, rightDriveEnc,  sensorQuadEncoder)
#pragma config(Sensor, dgtl12, liftStop,       sensorTouch)
#pragma config(Motor,  port1,           rightWheel1,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftLift1,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightLift1,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           leftWheel2,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightWheel2,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightLift2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightLift3,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftLift2,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftLift3,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftWheel1,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "JonLib/Vex_Competition_Includes_JON.c"

int autonomousChoice = -1;
bool debugMode = false;

//#include "JonLib/Math.h"
#include "JonLib/Drivebase.h"
#include "JonLib/PID.h"
#include "JonLib/Autonomous.h"
#include "JonLib/Gyro.h"
#include "JonLib/LCD.h"
#include "LCD.c"

void setLeftWheelSpeed (int speed) {
	motor[leftWheel1] = speed;
	motor[leftWheel2] = speed;
}

void setRightWheelSpeed (int speed) {
	motor[rightWheel1] = speed;
	motor[rightWheel2] = speed;
}

void tankDriveLimit (){
	if(abs(vexRT[Ch3])<120){
		setLeftWheelSpeed(vexRT[Ch3]);
	}
	else{
		setLeftWheelSpeed(0);
	}
	if(abs(vexRT[Ch2])<120){
		setRightWheelSpeed(vexRT[Ch2]);
	}
	else{
		setRightWheelSpeed(0);
	}
}

void lift (int speed, int slew) {
	if(abs(speed-motor[leftLift1])>slew) {
		if(motor[leftLift1]>speed)
			speed = motor[leftLift1]-slew;
		else
			speed = motor[leftLift1]+slew;
	}

	motor[leftLift1] = speed;
	motor[leftLift2] = speed;
	motor[leftLift3] = speed;
	motor[rightLift1] = speed;
	motor[rightLift2] = speed;
	motor[rightLift3] = speed;
}

void liftNoSlew (int speed) {
	motor[leftLift1] = speed;
	motor[leftLift2] = speed;
	motor[leftLift3] = speed;
	motor[rightLift1] = speed;
	motor[rightLift2] = speed;
	motor[rightLift3] = speed;
}

void lift (int speed) {
	lift(speed, 15);
}

void init() {
	startTask(LCD);
}

void pre_auton () {
	init();
}

void resetEncoders(int times) {
	SensorValue[leftDriveEnc] = 0;
	SensorValue[rightDriveEnc] = 0;
	delay(2);
	if(times>0) {
		resetEncoders(times-1);
	}
}

void resetEncoders () {
	resetEncoders(5);
}

void autonomousInit() {
  //clear the encoders before start of autonomous
	resetEncoders();


  //clear drivebase PID targets to prevent robot from running off anywhere
	l.target = 0;
	r.target = 0;

	startTask(drivebasePID);
}

task clawControl () {
	while(true) {
		if(vexRT[Btn6U]) {
			SensorValue[claw] = !SensorValue[claw];
			while(vexRT[Btn6U]) { delay(5); }
		}

		delay(25);
	}
}

void liftSequence () {
	setWheelSpeed(-20);
	liftNoSlew(127);
	delay(400);
	//delay(1000);
	setWheelSpeed(0);
	delay(200);
	liftNoSlew(0);
	delay(300);

	setWheelSpeed(127);
	delay(300);

	liftNoSlew(-127);
	while(!SensorValue[liftStop]) { delay(5); }
	liftNoSlew(-15);
	setWheelSpeed(0);
}

enum {OPEN = 1, CLOSED = 0};

//task autonomous () {
//	resetGyro();
//	setWheelSpeed(127,0);
//	delay(2000);
//	leftSwingStop(0,10);
//	setWheelSpeed(0);
//}

//task autonomous() {
//	resetEncoders();
//	resetGyro();
//	StartTask(drivebasePID);
//	addTargetAuto(3000);
//}


#define LIFT_LOWER_LIMIT 4095
#define LIFT_RAISE 3400
#define LIFT_VERT 2082
#define LIFT_THROW 2000
int liftDiff;

task calculateLiftDifferience () {
	while(true) {
		if(SensorValue[liftStop])
			liftDiff = LIFT_LOWER_LIMIT-SensorValue[liftEnc];
		delay(25);
	}
}

int getLiftEncoder() {
	return SensorValue[liftEnc]+liftDiff;
}

pid liftPID;
void liftControlInit() {
	liftPID.kP = 0.1;
	liftPID.kI = 0.0;
	liftPID.kD = 0.8;
	liftPID.integral = 0.0;
	liftPID.target = SensorValue[liftEnc];
}

task liftControl () {
	liftControlInit();
	while(true) {
		liftPID.error = getLiftEncoder() - liftPID.target;

		liftPID.integral = liftPID.integral + liftPID.error;
		if(liftPID.error == 0)
			liftPID.integral = 0;
		if(abs(liftPID.error)>200)
			liftPID.integral = 0;

		liftPID.derivative = liftPID.error - liftPID.lastError;
		liftPID.lastError = liftPID.error;

		lift(liftPID.kP*liftPID.error+liftPID.kI*liftPID.integral+liftPID.kD*liftPID.derivative);
	}
}

void setLiftTarget (int target) {
	liftPID.target = target;
}

void liftAuto (int target) {
	startTask(liftControl);
	setLiftTarget(target);
}

void lowerLiftWait() {
	stopTask(liftControl);
	while(getLiftEncoder()<LIFT_RAISE-400) {
		lift(-127);
		delay(5);
	}
	while(!SensorValue[liftStop]) {
		lift(-30,20);
		delay(5);
	}
	liftNoSlew(0);
}

task lowerLiftTask() {
	lowerLiftWait();
}

void lowerLift() {
	startTask(lowerLiftTask);
}

void throw() {
	stopTask(liftControl);
	while(SensorValue[liftEnc]>LIFT_THROW) {
		liftNoSlew(127);
		delay(5);
	}
	SensorValue[claw] = 1;
	liftNoSlew(0);
	setLiftTarget(LIFT_THROW);
}

void openClaw() {
	SensorValue[claw] = 1;
}

void closeClaw() {
	SensorValue[claw] = 0;
}

void deploy() {
	openClaw();
	delay(150);
}

void stopAutonomous() {
	closeClaw();
	stopTask(liftControl);
	stopTask(drivebasePID);
	stopTask(drivebaseGyroPID);
	setWheelSpeed(0,0);
	liftNoSlew(0);
}


//cornerstar
//centre cube
void autonomousLeft2(bool cube) {
	float c = 4.0/2.75;
	resetGyro();
	resetEncoders();
	liftControlInit();
	delay(50);

	startTask(drivebaseGyroPID);

	deploy();

	delay(1000);
	addTarget(500*c);
	delay(1500);
	SensorValue[claw] = 0;
	addTarget(0);
	delay(400);
	liftAuto(LIFT_RAISE);

	//resetEncoders();
	//setTargetAuto(-975,-975);
	stopTask(drivebaseGyroPID);
	leftSwingStop(630,10);
	startTask(drivebasePID);
	addTargetAuto(-1000*c,-1000*c);
	stopTask(drivebasePID);
	setWheelSpeed(-50);
	delay(500);
	throw();
	setWheelSpeed(-30);
	delay(500);

	//cubetime
	if(cube) {
		resetGyro();
		lowerLift();
		setWheelSpeed(-30);
		resetEncoders();
		delay(200);
		startTask(drivebaseGyroPID);
		addTarget(300*c);
		delay(500);
		stopTask(drivebaseGyroPID);
		rightSwingStop(600,10);
		setWheelSpeed(0,0);
		delay(200);

		resetGyro();
		startTask(drivebaseGyroPID);
		resetEncoders();
		addTarget(1200*c);
		delay(1200);
		SensorValue[claw] = 0;
		addTarget(0);
		liftAuto(LIFT_RAISE);
		delay(300);
		stopTask(drivebaseGyroPID);
		setWheelSpeed(0);
		rightSwingStop(-560, 10);
		setWheelSpeed(0);
		delay(100);
		setWheelSpeed(-40);
		delay(200);
		throw();
	}

	delay(100);
	setWheelSpeed(0);
}

//back three stars, dump
//cube, dump
void autonomousLeft1(bool cube, bool corner) {
	float c = 4.0/2.75;
	resetGyro();
	resetEncoders();
	liftControlInit();
	delay(50);

	startTask(drivebaseGyroPID);

	deploy();

	delay(1000);
	addTarget(1400*c);
	delay(1500);
	SensorValue[claw] = 0;
	addTarget(0);
	delay(300);
	liftAuto(LIFT_RAISE);

	//resetEncoders();
	//setTargetAuto(-975,-975);
	setTargetAuto(500*c,500*c);
	stopTask(drivebaseGyroPID);
	rightSwingStop(-550,10);
	startTask(drivebasePID);
	addTarget(-1300*c,-1300*c);
	delay(800);
	stopTask(drivebasePID);
	setWheelSpeed(-70);
	throw();
	delay(200);
	setWheelSpeed(-30);

	//cubetime
	if(cube) {
		resetGyro();
		lowerLift();
		setWheelSpeed(-30);
		resetEncoders();
		startTask(drivebaseGyroPID);
		addTarget(300*c);
		delay(100);
		stopTask(drivebaseGyroPID);
		rightSwingStop(540,10);
		setWheelSpeed(0,0);
		delay(200);

		resetGyro();
		startTask(drivebaseGyroPID);
		resetEncoders();
		addTarget(1200*c);
		delay(1000);
		SensorValue[claw] = 0;
		delay(200);
		addTarget(0);
		liftAuto(LIFT_RAISE);
		setTargetAuto(0);
		stopTask(drivebaseGyroPID);
		setLeftWheelSpeed(0);
		rightSwingStop(-560, 10);
		delay(100);
		setWheelSpeed(-40);
		delay(100);
		throw();
	}

	//timeforcornerstar

	if(corner) {
		delay(200);
		resetGyro();
		lowerLift();
		resetEncoders();
		startTask(drivebaseGyroPID);
		addTarget(1500);
		delay(2300);
		closeClaw();
		setLiftTarget(LIFT_RAISE);
		addTargetAuto(-700);
		stopTask(drivebaseGyroPID);
		setWheelSpeed(-60);
		delay(200);
		throw();
		delay(600);
		setWheelSpeed(-30);
		delay(200);
	}

	stopTask(drivebasePID);
	stopTask(drivebaseGyroPID);
	stopTask(liftControl);
	setWheelSpeed(0);
}

//cornerstar
//centre cube
void autonomousRight2(bool cube) {
	float c = 4.0/2.75;
	resetGyro();
	resetEncoders();
	liftControlInit();
	delay(50);

	startTask(drivebaseGyroPID);

	deploy();

	delay(1000);
	addTarget(500*c);
	delay(1500);
	SensorValue[claw] = 0;
	addTarget(0);
	delay(400);
	liftAuto(LIFT_RAISE);

	//resetEncoders();
	//setTargetAuto(-975,-975);
	stopTask(drivebaseGyroPID);
	rightSwingStop(-650,10);
	startTask(drivebasePID);
	addTargetAuto(-1000*c,-1000*c);
	stopTask(drivebasePID);
	setWheelSpeed(-50);
	delay(500);
	throw();
	setWheelSpeed(-30);
	delay(500);

	//cubetime
	if(cube) {
		resetGyro();
		lowerLift();
		setWheelSpeed(-30);
		resetEncoders();
		startTask(drivebaseGyroPID);
		addTarget(300*c);
		delay(500);
		stopTask(drivebaseGyroPID);
		leftSwingStop(-500,10);
		setWheelSpeed(0,0);
		delay(200);

		resetGyro();
		startTask(drivebaseGyroPID);
		resetEncoders();
		addTarget(1200*c);
		delay(1200);
		SensorValue[claw] = 0;
		addTarget(0);
		liftAuto(LIFT_RAISE);
		delay(300)
		stopTask(drivebaseGyroPID);
		setWheelSpeed(0);
		leftSwingStop(650, 10);
		setWheelSpeed(0);
		delay(100);
		setWheelSpeed(-40);
		delay(200);
		throw();
	}

	delay(100);
	setWheelSpeed(0);
}

//back three stars, dump
//cube, dump
void autonomousRight1(bool cube, bool corner) {
	float c = 4.0/2.75;
	resetGyro();
	resetEncoders();
	liftControlInit();
	delay(50);

	startTask(drivebaseGyroPID);

	deploy();

	delay(1000);
	addTarget(1400*c);
	delay(1500);
	SensorValue[claw] = 0;
	addTarget(0);
	delay(300);
	liftAuto(LIFT_RAISE);

	//resetEncoders();
	//setTargetAuto(-975,-975);
	setTargetAuto(200*c,200*c);
	stopTask(drivebaseGyroPID);
	leftSwingStop(670,10);
	startTask(drivebasePID);
	addTargetAuto(-1300*c,-1300*c);
	stopTask(drivebasePID);
	setWheelSpeed(-70);
	delay(700);
	throw();
	setWheelSpeed(-30);
	delay(400);

	//cubetime
	if(cube) {
		resetGyro();
		lowerLift();
		setWheelSpeed(-30);
		resetEncoders();
		startTask(drivebaseGyroPID);
		addTarget(300*c);
		delay(500);
		stopTask(drivebaseGyroPID);
		leftSwingStop(-535,10);
		setWheelSpeed(0,0);
		delay(200);

		resetGyro();
		startTask(drivebaseGyroPID);
		resetEncoders();
		addTarget(1200*c);
		delay(1200);
		SensorValue[claw] = 0;
		delay(200);
		addTarget(0);
		liftAuto(LIFT_RAISE);
		setTargetAuto(100);
		stopTask(drivebaseGyroPID);
		setWheelSpeed(0);
		leftSwingStop(570, 10);
		setWheelSpeed(0);
		delay(100);
		setWheelSpeed(-40);
		delay(400);
		throw();
	}

	//timeforcornerstar
	if(corner) {
		delay(200);
		resetGyro();
		lowerLift();
		resetEncoders();
		startTask(drivebaseGyroPID);
		addTarget(1500);
		delay(2000);
		closeClaw();
		setLiftTarget(LIFT_RAISE);
		addTargetAuto(-700);
		stopTask(drivebaseGyroPID);
		setWheelSpeed(-60);
		delay(1000);
		setWheelSpeed(-30);
		delay(200);
		throw();
	}
	stopTask(drivebasePID);
	stopTask(drivebaseGyroPID);
	stopTask(liftControl);
	setWheelSpeed(0);
}

void autonomousSkills() {
	clearDebugStream();
	float c = 4.0/2.75;
	resetGyro();
	resetEncoders();
	delay(50);

	startTask(drivebaseGyroPID);
	SensorValue[claw] = 1;
	delay(1200);
	addTarget(1400*c);
	delay(1500);
	SensorValue[claw] = 0;
	addTarget(0);
	delay(300);
	while(SensorValue[liftEnc]>LIFT_RAISE) {
		liftNoSlew(127);
		delay(5);
	}
	liftNoSlew(15);

	//resetEncoders();
	//setTargetAuto(-975,-975);
	setTargetAuto(600*c,600*c);
	stopTask(drivebaseGyroPID);
	rightSwingStop(-600,10);
	startTask(drivebasePID);
	addTargetAuto(-600*c,-600*c);
	stopTask(drivebasePID);
	setWheelSpeed(-50);
	delay(1000);

	while(SensorValue[liftEnc]>LIFT_VERT) {
		liftNoSlew(127);
		delay(5);
	}

	liftNoSlew(0);
	SensorValue[claw] = 1;
	delay(500);
	setWheelSpeed(-20);

	for(int i = 0; i<3; i++) {
		resetGyro();

		resetEncoders();
		delay(200);

		StartTask(drivebaseGyroPID);
		addTarget(1200*c, 1200*c);
		while(SensorValue[liftEnc]<LIFT_RAISE) {
			liftNoSlew(-60);
			delay(5);
		}
		while(!SensorValue[liftStop]) {
			liftNoSlew(-30);
			delay(5);
		}
		liftNoSlew(0);

		delay(2000);

		SensorValue[claw] = 0;

		setTarget(0*c,0*c);
		delay(600);
		StopTask(drivebaseGyroPID);
		setWheelSpeed(-50);
		delay(200);
		while(SensorValue[liftEnc]>LIFT_VERT)
			liftNoSlew(127);
		liftNoSlew(0);
		setWheelSpeed(-10);

		SensorValue[claw] = 1;
		delay(300);
	}

	//newcube

	if(true) {
		startTask(drivebasePID);
		setWheelSpeed(-30);
		while(!SensorValue[liftStop]) {
			liftNoSlew(-30);
			delay(5);
		}
		liftNoSlew(0);
		setWheelSpeed(0);
		resetEncoders();
		addTarget(300*c);
		delay(500);
		stopTask(drivebasePID);
		resetGyro();
		rightSwingStop(550,10);
		resetGyro();
		startTask(drivebaseGyroPID);
		resetEncoders();
		addTarget(1200*c);
		delay(1200);
		SensorValue[claw] = 0;
		stopTask(drivebaseGyroPID);
		setWheelSpeed(0);
		delay(400);
		startTask(drivebasePID);
		setTarget(100,100);
		while(SensorValue[liftEnc]>LIFT_RAISE)
			liftNoSlew(127);
		liftNoSlew(15);
		delay(1200);
		stopTask(drivebasePID);
		setWheelSpeed(-10,-80);
		delay(700);
		setWheelSpeed(-60);
		delay(400);
		while(SensorValue[liftEnc]>LIFT_VERT) {
			liftNoSlew(127);
			delay(5);
		}
		liftNoSlew(0);
		setWheelSpeed(-30);
		delay(100);
		SensorValue[claw] = 1;
		delay(300);
	}

	//closestars
	if(true) {
		stopTask(drivebasePID);
		setWheelSpeed(-30);
		while(!SensorValue[liftStop]) {
			liftNoSlew(-30);
			delay(5);
		}
		liftNoSlew(0);
		stopTask(drivebasePID);
		setWheelSpeed(0);
		resetGyro();
		//rightSwingStop(650,10);
		//setWheelSpeed(-60);
		delay(220);
		rightSwingStop(720,10);
		setWheelSpeed(0);
		delay(200);
		setWheelSpeed(-60);
		delay(2000);
		setWheelSpeed(0);
		delay(300);
		resetGyro();
		delay(200);
		resetEncoders();
		startTask(drivebaseGyroPID);
		gyroP = 2.0;
		addTargetAuto(2000*c);
		SensorValue[claw] = 0;
		addTargetAuto(500*c);
		gyroP = 0.6;
		while(SensorValue[liftEnc]>LIFT_RAISE)
			liftNoSlew(50);
		liftNoSlew(12);
		stopTask(drivebaseGyroPID);
		setWheelSpeed(0);
		delay(300);
		setWheelSpeed(50,-50);
		delay(560);
		setWheelSpeed(0);
		delay(300);
		setWheelSpeed(-50);
		delay(500);
		while(SensorValue[liftEnc]>LIFT_VERT)
			liftNoSlew(127);
		liftNoSlew(0);
		delay(100);
		SensorValue[claw] = 1;
		delay(300);
	}


	//while(true) {

	//}

	//BACKCUBE
	if(true) {
		while(!SensorValue[liftStop]) {
			liftNoSlew(-30);
			delay(5);
		}
		liftNoSlew(0);

		resetEncoders();
		resetGyro();
		StartTask(drivebaseGyroPID);
		setTarget(1400*c, 1400*c);

		delay(1700);

		SensorValue[claw] = 0;

		setTarget(-1200*c,-1200*c);
		delay(850);
		while(SensorValue[liftEnc]>-650)
			liftNoSlew(127);
		liftNoSlew(0);
		StopTask(drivebaseGyroPID);
		setWheelSpeed(-20);

		SensorValue[claw] = 1;
		delay(300);
	}

	//CORNERSTAR
	if(true) {
		while(!SensorValue[liftStop]) {
			liftNoSlew(-30);
			delay(5);
		}
		liftNoSlew(0);

		resetGyro();
		rightSwingStop(650,10);
		setWheelSpeed(-60);
		delay(280);
		rightSwingStop(800,10);
		delay(75);
		setWheelSpeed(0,0);
		leftSwingStop(100,20);

		resetEncoders();
		StartTask(drivebaseGyroPID);
		addTargetAuto(1000*c, 1000*c);

		delay(600);

		SensorValue[claw] = 0;

		while(SensorValue[liftEnc]>-400)
			liftNoSlew(127);
		liftNoSlew(0);

		addTarget(-2000*c);
		delay(700);
		while(SensorValue[liftEnc]>-650)
			liftNoSlew(127);
		liftNoSlew(0);
		StopTask(drivebaseGyroPID);
		setWheelSpeed(-10);

		SensorValue[claw] = 1;
		delay(300);
	}

	//WE ARE ON THE LIFT
	if(false) {
		while(SensorValue[liftEnc]<-600)
			liftNoSlew(-40);
		liftNoSlew(0);
		resetEncoders();
		startTask(drivebaseGyroPID);
		addTarget(1500*c, 1500*c, 50);
		delay(5000);
		stopTask(drivebaseGyroPID);
		maxSpeedSwing = 60;
		rightSwingStop(-800, 10);
		setWheelSpeed(-50);
		delay(1000);
		resetGyro();
		leftSwingStop(-380, 10);
		setWheelSpeed(-50);
		delay(1000);
		liftSequence();

	}

	stopTask(drivebasePID);
	setWheelSpeed(0);
	delay(1000);
	//while(!SensorValue[liftStop]) {
	//	liftNoSlew(-127);
	//	delay(5);
	//}
	liftNoSlew(0);
}

void liftSetpointTest() {
	liftControlInit();
	StartTask(calculateLiftDifferience);
	while(true) {
		SensorValue[claw] = 0;
		startTask(liftControl);
		setLiftTarget(LIFT_RAISE);
		delay(2000);
		throw();
		delay(2000);
		stopTask(liftControl);
		lowerLift();
		delay(2000);
	}
}

task batteryLCD() {
	while(true) {
		bLCDBacklight = true;
		string mainBatteryStatus, backupBatteryStatus;
		sprintf(mainBatteryStatus,"Cortex: %1.2f%c V", nImmediateBatteryLevel/1000.0);
		sprintf(backupBatteryStatus,"Xpander: %1.2f%c V", SensorValue[powerExpander]/280.0);
		displayLCDString(0, 0, mainBatteryStatus);
		displayLCDString(1, 0, backupBatteryStatus);
		delay(60000);
	}
}

task autonomous() {
	startTask(calculateLiftDifferience);
	startTask(batteryLCD);
	switch (autonomousChoice) {
		case 0: autonomousLeft1(true, true);		break;
		case 1:	autonomousLeft1(true, false);		break;
		case 2:	autonomousLeft1(false, false);	break;
		case 3: autonomousLeft2(true); 					break;
		case 4: autonomousLeft2(false);					break;
		case 5: autonomousRight1(true, true);		break;
		case 6:	autonomousRight1(true, false);	break;
		case 7:	autonomousRight1(false, false);	break;
		case 8: autonomousRight2(true); 				break;
		case 9: autonomousRight2(false);				break;
	}
}

task usercontrol() {
	startTask(LCD);
	startTask(clawControl);
	bool orienting = false;
	while(true) {
		if(!debugMode) {
			tankDrive(vexRT[Ch3], vexRT[Ch2], 15);
			//tankDriveLimit(); //wtf
 			if(vexRT[Btn8L]) {
				liftSequence();
			} else if(vexRT[Btn8U]) {
				liftNoSlew(-127);
			} else if(vexRT[Btn5U]) {
				liftNoSlew(127);
			} else if(vexRT[Btn5D] && (!SensorValue[liftStop])) {
				liftNoSlew((SensorValue[liftEnc]>LIFT_RAISE-400)?-30:-127);
			} else if(SensorValue[liftStop]) {
				liftNoSlew(-10);
			} else {
				lift((SensorValue[liftEnc]>LIFT_VERT+500)?10:-15,12);
			}
		}

		if(SensorValue[liftStop])
			SensorValue[liftEnc] = 0;

		if(vexRT[Btn7L])
			gyroscope.target = SensorValue[gyro];
		if(vexRT[Btn7R] && !orienting){
			StartTask(orient);
			orienting = true;
		} else if(!vexRT[Btn7R] && orienting) {
			StopTask(orient);
			orienting = false;
		}

		delay(25);
		}
}
